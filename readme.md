## Алгоритмы

- ### generatePresetImpl

Метод формирует пресет армии компьютера, то есть максимально эффективный по соотношению атаки к стоимости в первую очередь и соотношению здоровья к стоимости набора юнитов разного типа таким образом, чтобы при этом соблюдалось ограничение в 11 юнитов каждого типа.
    
Итоговая сложность алгоритма: O(n * log n) 

Складывается из:
- Сортировка: O(n * log n)
- Внутренний while-цикл: O(n)

- ### simulateBattleImpl

Этот метод осуществляет симуляцию боя между армией игрока и армией компьютера. Цель метода — провести бой, следуя установленным правилам.

Итоговая сложность алгоритма: O(n²)

Складывается из:
- Сортировка: O(n * log n)
- while-цикл внутри другого while-цикл: O(n²)

Алгометрическая сложность метода hasAliveUnits O(n) также вложена в основной while-цикл, поэтому итоговая сложность O(n²)

- ### suitableForAttackUnitsFinderImpl

Метод формирует пресет армии компьютера, то есть максимально эффективный по соотношению атаки к стоимости в первую очередь и соотношению здоровья к стоимости набора юнитов разного типа таким образом, чтобы при этом соблюдалось ограничение в 11 юнитов каждого типа.

Итоговая сложность алгоритма: O(n) (если учесть что количество рядов фиксировано и равно трём)

Складывается из:
- цикл for (Unit unit : unitsByRow.get(i)) внутри другого цикла for, но так как у вышестоящего цикла всегда фиксированое колличество проходов (3), учитываем только один for: O(n)

- ### UnitTargetPathFinderImpl

Метод формирует пресет армии компьютера, то есть максимально эффективный по соотношению атаки к стоимости в первую очередь и соотношению здоровья к стоимости набора юнитов разного типа таким образом, чтобы при этом соблюдалось ограничение в 11 юнитов каждого типа.

При выполнении данного задания использовался алгоритм Дейкстры - алгоритм поиска кратчайшего пути от одной заданной вершины до всех остальных в взвешенном графе

Итоговая сложность алгоритма: O((W * H) * log (W * H)),
где W = Width, H = Height

Складывается из:
- цикла for (Unit unit : existingUnitList) так как колличество юнитов меньше чем W * H, цикл можно не учитывать.
- цикла while (!queue.isEmpty()): O(n), где n - кол-во ребер
- инициализация массивов distance и previous: O(W * H)
- poll() из PriorityQueue: O(log (W * H))
- add(): O(log (W * H))
- Суммарная сложность алгоритма Дейкстры: O((W * H) * log (W * H))
